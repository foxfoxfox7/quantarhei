# QUANTArhei: Open Quantum System Theory for Molecular Systems

### See below for some example edits by Kieran Fox

Quantarhei is in flux, but it already provides helper classes to define
molecules, their aggregates and their interaction with external environment.
It can calculate absorption spectra of individual molecules and their
aggregates and excitation energy transfer dynamics using various types
of Redfield and Foerster theories.

Quantarhei provides Python code (optimized with Numpy) for all its implemented
methods and theories, and allows extensions and replacements of the reference
Python code with optimised routines written in C, Fortran or other lower level
languages.

In the first development stage, we concentrate on bringing to you tools
to quickly build essential components of a quantum mechanical simulation,
such as Hamiltonian, relaxation tensors, various initial
conditions for density matrix etc.

Quantarhei is available in source form on GitHub and from PyPI for installation
with the pip command.

# Kieran Fox's edits to the python package quantarhei

As well as adapting the package to my specific projects, I have used this branch to make contributions to the way certain elements of the package runs. (See below my edits for a full description of the package). In addition to this I have found and corrected a number of bugs.

### saving data as an instance variable or writing it out to a dictionary using numpy

In order to obtain reliable output data, calculations need to run up to 1000 times using the Monte-Carlo method. The data is generated, processed, and then summed. With my changes, the data can now be output as it is generated and summed straight away as all future processes are linear. This means it only takes up as much RAM as simulations are run simultaneously. It also massively speeds up the computational process as the post-processing only needs to be done once at the end.

~~~python
self.responses = []
~~~

Is added to the \_\_init__. Added as a list as many can be calculated for different setups in one class instance.

~~~python
def bootstrap(self, rwa=0.0, pad=0, lab=None, verbose=False, 
              write_resp = False, keep_resp = False):
    """Sets up the environment for 2D calculation
    write_resp takes a string, creates a directory with the name of
    the string and saves the respoonses and time axis as a npz file
        
    keep_resp saves the responses as a list of dictionaries. The 
    list goes through the time points in t2.
        
    """


    self.verbose = verbose
    self.pad = pad
    self.write_resp = write_resp
    self.keep_resp = keep_resp

    if self.write_resp:
        try:
            os.mkdir(write_resp)
        except OSError:
            print ("Creation of the directory failed, it either already "
                "exists or you didn't give a string")
~~~

Here the instructions are given at bootstrap as they will be needed for multiple methods in the class.

~~~python
if self.keep_resp:
    resp = {
        'time': self.t1axis.data, 'time_pad': t13Pad.data,
        'rTot': resp_r, 'nTot': resp_n,
        'rGSB': resp_Rgsb, 'nGSB': resp_Ngsb,
        'rSE': resp_Rse, 'nSE': resp_Nse,
        'rESA': resp_Resa, 'nESA': resp_Nesa,
        'rSEWT': resp_Rsewt, 'nSEWT': resp_Nsewt,
        'rESAWT': resp_Resawt, 'nESAWT': resp_Nesawt
        }
        self.responses.append(resp)
            
if self.write_resp:
    numpy.savez('./'+self.write_resp+'/respT'+str(int(tt2))+'.npz',
        time = self.t1axis.data, time_pad=t13Pad.data,
        rTot=resp_r, nTot=resp_n,
        rGSB=resp_Rgsb, nGSB=resp_Ngsb,
        rSE=resp_Rse, nSE=resp_Nse,
        rESA=resp_Resa, nESA=resp_Nesa,
        rSEWT=resp_Rsewt, nSEWT=resp_Nsewt,
        rESAWT=resp_Resawt, nESAWT=resp_Nesawt)
~~~

### Padding the generated time series with zeros

This package simulates spectroscopy data (the observations after shining a light on a sample) by generating a time series and then Fourier transforming into the frequency domain. The time series is generated by the multiple transformations of a 'density matrix' (which describes the state of the system) by a calculated tensor. However, under certain conditions, after some time the generated time series is vanishingly small. However these points are needed for the resolution in the frequency domain after Fourier transform. I gave the option of padding data with zeros so that far fewer calculations are necessary while still getting essentially the same results.

~~~python
def bootstrap(self, rwa=0.0, pad=0, lab=None, verbose=False, 
              write_resp = False, keep_resp = False):
~~~

Again making the option part of the bootstrap line as it is needed in multiple functions.

~~~python
# pad is set to 0 by default. if changed in the bootstrap,
# responses are padded with 0s and the time axis is lengthened
t13Pad = TimeAxis(self.t1axis.start, self.t1axis.length + self.pad, self.t1axis.step)
if self.pad > 0:
    self._vprint('padding by - ' + str(self.pad))

    t13Pad.atype = 'complete'
    t13PadFreq = t13Pad.get_FrequencyAxis()
    t13PadFreq.data += self.rwa
    t13PadFreq.start += self.rwa

    onetwod.set_axis_1(t13PadFreq)
    onetwod.set_axis_3(t13PadFreq)

# Sloping the end of the data down to 0 to there isn't a 
# hard cutoff at the end of the data
    from scipy import signal as sig
    window = 20
    tuc = sig.tukey(window * 2, 1, sym = False)
    for k in range(len(resp_r)):
        resp_r[len(resp_r)-window:,k] *= tuc[window:]
        resp_r[k,len(resp_r)-window:] *= tuc[window:]
        resp_n[len(resp_n)-window:,k] *= tuc[window:]
        resp_n[k,len(resp_n)-window:] *= tuc[window:]

    resp_r = numpy.hstack((resp_r, numpy.zeros((resp_r.shape[0], self.pad))))
    resp_r = numpy.vstack((resp_r, numpy.zeros((self.pad, resp_r.shape[1]))))
    resp_n = numpy.hstack((resp_n, numpy.zeros((resp_n.shape[0], self.pad))))
    resp_n = numpy.vstack((resp_n, numpy.zeros((self.pad, resp_n.shape[1]))))
~~~

The time series is generated in two dimensions and in many cases, 70% can be replaced with padded zeros. This means a decrease in computational time of up to 91% which has been crucial in my work as I needed to calculate large amounts of data and the time taken with the original method whould have been prohibitively long.

### Added a new spectral density function

This function describes the electronic states of a molecules. There are many energy levels that a molecule can exist in and for each of these, there a range of vibrational energy levels. These are determined as accurately as possible from experiment (by shining lasers at molecules at observing the light afterwards) or from theory (quantum mechanical calculations). They form a distribution and the shape of this distribution determines the behaviour of the molecule. 

~~~python
# See Renger, Journal of Chemical Physics 2002
# See Jang, Newton, Silbey, J Chem Phys. 2007 for alternate form
# (See Kell et al, 2013, J. Phys. Chem. B.)
def _make_B777(self, params, values=None):

    with energy_units("int"):
        omega = self.axis.data
        cfce=0

        if not params["alternative_form"]:

            try:
                ss = [params['s1'], params['s2']]
                    freq = [params["freq1"], params["freq2"]]
            except:
                ss = [0.8, 0.5]
                freq = [convert(0.56, "1/cm", "int"), convert(1.9, "1/cm", "int")]

            for ii in range(2):
                cfce = cfce+\
                (ss[ii]/(numpy.math.factorial(7)*2*(freq[ii]**4)))*\
                (omega**3)*(numpy.exp(-numpy.abs(omega/freq[ii])**0.5))
            # Converts the form of the spectral density to the 
            # one used in Quantarhei
            cfce = cfce * (omega**2)
            # Brings the reorganisation energy to the lit value of 102
            cfce = cfce * 3.204215
            print("Renger form of spec dens used")

        else:

            # This form is taken from Jang, Newton, 
            # Silbey, J Chem Phys. 2007.
            #It gives a polynomial form of the B777 spectral density
            try:
                omega1c = convert(params['om1'], "1/cm", "int")
                omega2c = convert(params['om2'], "1/cm", "int")
                omega3c = convert(params['om3'], "1/cm", "int")
            except:
                omega1c = convert(170, "1/cm", "int")
                omega2c = convert(34, "1/cm", "int")
                omega3c = convert(69, "1/cm", "int")

            with energy_units("int"):
                # (omega/(numpy.abs(omega))) in the second term ensures
                # proper treatment of -ve frequencies
                omega = self.axis.data
                cfce = \
                0.22*omega*numpy.exp(-numpy.abs(omega/omega1c))+\
                0.78*(omega/(numpy.abs(omega)))*((omega**2)/omega2c)*numpy.exp(-numpy.abs(omega/omega2c))+\
                0.31*((omega**3)/(omega3c**2))*numpy.exp(-numpy.abs(omega/omega3c))
            # Brings the reorganisation energy to the lit value of 102
            cfce = cfce * 3.058187
            print('Alternate form of spec dens used')

    if values is not None:
        self._make_me(self.axis, values)
    else:
        self._make_me(self.axis, cfce)

    self.lamb = params["reorg"]
    self.lim_omega = numpy.zeros(2)
    self.lim_omega[0] = 0.0
    self.lim_omega[1] = 0.0
~~~

The function I have implemented here can be called in two forms depending on the parameters inputted.
